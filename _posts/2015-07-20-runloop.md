---
layout: post
title:  "RunLoop"
category: 知识碎片
date:   2015-07-20
---

##介绍

无论是有GUI的Mac应用，还是iOS的应用，都是通过用户选择菜单、点击（或拖拽）或者操作键盘而做出反应的一切操作。这些程序和命令行程序相比有很大的不同。

这些应用从操作系统中接收鼠标点击等时间的消息，并将转到对应的代码来处理，如此反复。这样的过程被称为运行回路（run loop）或 事件循环（event loop）。


运行回路从操作系统（精确的说是窗口的服务器）中接收事件，并根据事件种类和状态调用相应的程序，同时也会忽视那些没有必要处理的事件。这些事件非常随机，当应用程序正在处理某个事件消息时，新接收到的消息就不能立即被处理，而必须被放到等待队列中，等到空闲的时候才能被处理。没有消息到来的时候，应用会进入休眠等待的状态。


从应用程序开发者的角度来说，某个事件触发时，总有一个OC的对象接收到该事件消息。例如：在创建GUI应用时，每个GUI组件都有对应的动作消息（action message），当按钮、菜单等组件被点击时，这些行为消息就会被发送到相应的组件对象中处理。在视图上进行拖拽操作时也一样，视图方法会获取描述实际那的参数并传给视图对象，这样视图对象就能成功得拖拽操作的坐标等信息。

开发者只要集中精力实现消息事件的处理方法就ok了。实现用户的各种操作即可。需要实现并封装一些方法以应对用户发出的命令和操作。

因为Cocoa应用本身就有GUI功能，所以一旦开始运行，就一定会产生一个运行回路，叫主运行回路。同时，应用的事件处理或资源的管理功能需要有一个对象来完成，所以Mac OS X 中提供了NSApplication，iOS则提供了UIApplication类的实例，该实例会根据操作系统发送的事件选择对应的处理对象，并发送相应的消息。

回路运行后，当有新的事件消息到来而别的处理还没有结束的情况下，应用就可以把该事件放入等待队列中并在之后按照顺序来执行。这种事情非常适合多线程的一部执行。多线程应用的情况下，在应用的主运行回路之外，每个线程都会启动自己的运行回路，并将其用于线程间的通信等。应用使用NSRunloop类来访问运行回路。

在MRC中，主运行回路在启动事件处理方法时会生成一个自动释放池，并在方法终止的时候释放它。而垃圾回收的情况下，一个事件处理完后会启动一个垃圾回收器。应用中执行的方法基本是`自己管理自动释放池，不需要担心什么时候进行垃圾回收`。当然某个方法要生成很多临时对象，最好在合适的地方释放这些内存。而主线程之外执行的方法则要自己生成自动释放池。

参考资料：

* 《iOS RunLoop 初识》 <http://www.cnblogs.com/tangbinblog/archive/2012/12/07/2807088.html>
* 《 IOS 多线程 RUNLOOP 机制 (一) 》<http://blog.csdn.net/fengsh998/article/details/8601632>
