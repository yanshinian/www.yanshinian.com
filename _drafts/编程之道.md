
#你好设计模式


###1.5设计模式的起源----模型、视图和控制器（MVC）

#####1.5.1模型再对象中封装数据和基本行为

#####1.5.2视图对象向用户展示信息

#####1.5.3控制器对象联系模型和视图

#####1.5.4复合设计模式的MVC

MVC本身并不是最基本的设计模式，包含了若干更加基本的模式。基本设计模式相互配合，确定了各功能之间的协作。

Cocoa（Touch）的MVC 用到的模式有：组、命令、中介者、策略和观察者


###1.6 影响设计的几个问题

#####1，6.1 针对接口编程，而不是针对实现编程

定义具有相同接口的类群很重要，因为多态是基于接口的。

实现协议或者从抽象类继承，使得对象共享相同的接口。

好处：

* 只要对象对象符合客户端所要求的接口，客户端就不必在意所使用对象的确切类型；
* 客户端只知道定义接口的协议或者抽象类，因此客户端对对象的类一无所知。

客户端代码中不声明特定具体类的变量，而只使用协议或抽象类定义的接口。这种理念和思想贯穿本书。

#####1.6.2 @protocol 与 抽象基类

比如说有个协议叫Mark

```
id<Mark> thisMark;
```

如果Mark被声明为抽象基类，那么语法应该跟其他类一样

```
Mark *thisMark;
```

在接受以Mark协议的对象作为参数的方法中，语法应该是这样：

```
- (void)anOperaionWithMark:(id <Mark>) aMark;
```

如果Mark是抽象基类，那么语法是这样：

```
- (void)anOperaionWithMark:(Mark *)aMark;
```

Mark协议引用有些笨拙。但是为什么还要使用协议？

OC 不支持多重继承。如果一个类既要是UIView的子类，又钥匙定制的抽象类型，那么这个抽象类型就只能是协议而不能是抽象基类。


##### 1.6.3 对象组合与类继承

子类化常常被称为`白箱复用`，因为父类的内部描述与细节通常对子类可见。


类继承的优点：

* 简单直接，关系在编译时静态定义
* 被复用的实现易于修改

缺点：

* 类继承在编译时定义，所以无法在运行时变更从父类继承来的实现
* 子类的部分描述常常定义在父类中
* 子类直接面对父类实现的细节，因此破坏了封装
* 父类实现的任何变更都会强制子类也进行变更，因为他们的实现联系在了一起
* 在新的问题场景下继承来的实现已过时或不适用，所以必须重写父类或继承来的实现

由于实现的依存关系，对子类进行复用可能会有问题。有一个解决办法是，只从协议或抽象基类继承（子类化），因为它们只有很少的实现，协议则没有实现


`优先使用对象组合而不是类继承`























